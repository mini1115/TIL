### 트랜잭션
----
애플리케이션이 어떤 동시성 문제와 어떤 종류의 HW와 SW 결함이 존재하지 않는 것처럼 동작할 수 있게 도와주는 추상층
많은 종류의 오류가 간단한 트랜잭션 어보트로(Abort) 줄어들고 애플리케이션은 재시도만 하면 된다.

  - 단일 레코드만 읽거나 쓰는 것처럼 접근 패턴이 아주 단순한 애플리케이션은 트랜잭션 없이도 관리할 수 있을지 모른다.
  - 그러나 접근 패턴이 복잡할 때는 트랜잭션이 상상할 수 있는 잠재적인 오류 상황의 수를 크게 줄여줄 수 있다.
  - 트랜잭션이 없으면 다양한 오류 시나리오(프로세스가 죽거나 네트워크가 끊기거나 정전이 되거나 디스크가 가득거나 예측하지 못한 동시성 문제 등)에서 다양한 방법으로 데이터 일관성이 깨질수 있다.
    - 예를 들어, 비정규화된 데이터는 원천 데이터와 동기화가 깨지기 쉽다. 트랜잭션이 없다면 복잡한 상호작용을 하는 접근이 데이터베이스에 미치는 영향을 따져보기가 매우 어려워진다.

#### 더티 읽기
    한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 읽는다. 커밋 후 읽기 또는 그보다 강한 격리 수준은 더티 읽기를 방지한다.

#### 더티 쓰기
    한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티 쓰기를 방지한다.

#### 읽기 스큐 Skew(비반복 읽기)
    클라이언트는 다른 시점에 데이터베이스의 다른 부분을 본다. 이 문제를 막기 위한 해결책으로 트랜잭션이 어느 시점의 일관된 스냅숏(SnapShot)으로부터 읽는 스냅숏 격리를 가장 흔히 사용한다.
    스냅숏 격리는 보통 다중 버전 동시성 제어(MVCC)를 써서 구현한다. 
    스냅숏 : 데이터베이스 트랜잭션이 시작될 때 해당 시점의 데이터 상태를 복사한 일종의 정지 이미지 또는 사본  

#### 갱신 손실
    두 클라이언트가 동시에 read-modify-write 주기를 실행한다. 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터가 손실된다. 스냅숏 격리 구현 중 어떤 것은 이런 현상을 자동으로 막아주지만 그렇지 않은 것은 수동 잠금(SELECT FOR UPDATE)이 필요하다.

#### 쓰기 스큐 Skew
    트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 쓴다. 그러나 쓰기를 실행하는 시점엣는 결정 전제가 더 이상 참이 아니다. 직렬성 격리만 이런 현상을 막을 수 있다.
      직렬성 격리 : 트랜잭션들이 동시에 실행되어도 순차적으로 실행된 것과 같은 효과를 보장한다.
#### 팬텀(Phantom) 읽기
    트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행한다. 스냅숏 격리는 간단한 팬텀 읽기를 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요하다.
      팬텀 : 한 트랜잭션이 특정 조건에 따라 데이터를 조회했을 때와 그 이후 다시 같은 조건으로 조회했을 때 결과가 다르게 나타나는 상황

#### 직렬성 격리 구현방법 3가지
---
1.  말 그대로 트랜잭션을 순서대로 실행하기
    - 트랜잭션의 실행 시간이 아주 짧고 트랜잭션 처리량이 단일 CPU 코어에서 처리할수 있을 정도로 트랜잭션 처리량이 낮다면 아주 간단하고 효과적인 선택이다.
2. 2단계 잠금(2PL)
    - 수십년 동안 직렬성을 구현하는 표준적인 방법이엇지만 성능 특성 때문에 사용을 피하는 애플리케이션이 많다.
3. 직렬성 스냅숏 격리(SSI)
    - 낙관적 방법을 사용해서 트랜잭션이 차단되지 않고 진행할수 있게 한다. 트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않다면 어보트(abort) 시킨다.

#### MVCC 가시성 규칙
    데이터베이스의 각 트랜잭션이 읽고 쓸 수 있는 데이터의 버전을 결정하는 기준입니다.
    1. 트랜잭션 시작 시점 기준 스냅숏 생성 : 트랜잭션이 시작되면 해당 시점의 데이터 스냅숏이 생성되며, 이후 트랜잭션은 다른 트랜잭션의 변경을 보지 않고 스냅숏을 기준으로 작업을 수행한다.
    2. 읽기 작업 시점에 맞는 버전 선택 : 읽기 시 트랜잭션 시작 시점이나 이전에 커밋된 데이터 버전만을 참조한다.
    3. 쓰기 시 버전 충돌 감지 : 트랜잭션이 데이터를 수정하고 커밋할 때는 현재 작업 중인 트랜잭션이 시작된 이후로 다른 트랜잭션에서 해당 데이터를 수정하지 않았는지 검토한다.
    4. 가시성 결정 기준 :  트랜잭션이 볼 수 있는 데이터 버전은 트랜잭션의 시작 시점과 그 이전에 커밋된 버전으로 한정되며, 아직 커밋되지 않은 데이터는 다른 트랜잭션에서 가시성이 없다. 이를 통해 일관성과 트랜잭션 간 독립성을 보장한다.
  
