## 계수 정렬 Count Sort
    계수 정렬은 특정 조건이 부합시 사용 가능한 매우 빠른 알고리즘이다.
    데이터의 수 N 데이터의 최댓값 K 일경우 최악의 경우 O(N+K)의 시간복잡도를 보장한다.
    특정 조건 : 데이터 크기 범위가 제한되어 정수형태로 표현 가능할때만 가능하며, 최댓값과 최솟값의 차이가 일반적으로 1,000,000을 넘지 않아야한다.
    계수정렬은 데이터 최댓값 만큼 별도의 리스트를 선언하고 그 안에 빈도 정보를 담는다.
#### 시간복잡도
    앞서 언급했듯이 모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N, 데이터 중 최대값의 크기를 K라고 할때, 계수정렬의 시간복잡도는 O(N+K)이다.
    계수정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야 하기 때문이다.
    따라서 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다.
  ### 공간 복잡도
    계수 정렬은 떄에 따라 심각한 비효율성을 초래할수 있다.
    예를 들어 데이터가 0과 999,999 단 두개만 존재한다고 가정한다면, 이럴 때에도 리스크의 크기가 100만개 되도록 선언해야 한다.
    다시 말해서 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기(=값) 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다.
    
``` java
import java.util.*;
import java.io.*;

public class MyClass {
    static int[] array;
    public static void main(String args[]) {
        array = new int[]{7,5,9,0,3,1,6,2,9,1,4,8,0,5,2};
        // 데이터의 최대값 K
        int arr_max = Arrays.stream(array).max().orElseThrow();
        // 별도의 리스트 선언
        int[] count = new int[arr_max+1];
        
        for(int i=0;i<array.length;i++){
            count[array[i]] +=1;
        }
        int index = 0;
        //결과 출력
        for(int i=0;i<count.length;i++){
            for(int j=0;j<count[i];j++){
                System.out.print(i +" ");
            }
        }
    }
}
```
