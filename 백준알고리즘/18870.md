[문제](https://www.acmicpc.net/problem/18870)
#### 풀이
    문제를 이해하는데 다소 시간이 걸렸지만 
    입출력 예시를 보고 이해를 한다. 대충 인코딩과 비슷한 내용으로 중복을 제거한 배열 내 순서로 변환해 나타낸것이다.
    TreeSet을 활용하여 중복을 제거함과 동시에 정렬이 가능하도록 하였다.
    또한 Map을 사용하여 해당 자료의 key값과 순서 index를 value로 형식을 지정해주었다.

##### 시간복잡도
    O(N logN) = O(N) + O(N logN)
    O(N) : 인덱스 매핑
    O(NlogN) : 정렬 
##### 문제점
    출력과정에서 시간초과가 발생하였다.
    단순히 반복문으로 구현하여 출력물을 출력할것이 아니라 StringBuilder를 사용하여 결과값을 append()한 후에 toString()으로 출력하니 해결되었다. 
#### CODE
```JAVA
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String args[]) throws IOException {
        long answer =0;
        HashMap<Integer,Integer> info = new HashMap<>();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        // 좌표의 갯수
        int N= Integer.parseInt(st.nextToken());
        int[] X = new int[N];
        
        String[] data = br.readLine().split(" ");
        for(int i=0;i<N;i++){
            // 좌표 입력받기
            X[i] = Integer.parseInt(data[i]);
        }
        //원래의 배열에서 중복제거 후 정렬가능한 TreeSet
        Set<Integer> sortX = new TreeSet<>();
        for(int temp:X){
            sortX.add(temp);
        }

        int index=0;
        for(int num:sortX){
            // 중복 제거를 위한 메소드
            if(!info.containsKey(num)){
                info.put(num,index++);
            }
        }
        // 시간초과를 극복하기 위한 sb
        StringBuilder sb = new StringBuilder();
        for(int num:X){
            sb.append(info.get(num)).append(" ");
        }
        System.out.println(sb.toString());
    }
}

```
