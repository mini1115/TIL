[백준 1003](https://www.acmicpc.net/problem/1620)

#### 풀이 
    단순 재귀로 문제를 해결하려 했지만, 시간 제한이 0.25초 이기때문에 잘못된 접근이다.
    따라서 해결방법을 생각하던중에 점화식으로 DP를 통한 메모이제이션으로 해결하였다.

#### DP 메모이제이션 
    - 재귀적 구조 : F(N) = F(N-1) + F(N-2)
    - 결과 저장 : 각 하위 결과를 계산한 후 이를 메모리에 저장하고, 차후에 동일한 하위문제를 다시계산 X
    - 조회 : 결과가 존재한다면 메모리에 결과 호출, 존재하지않는다면 새로운 값으로 계산 후 메모리 저장
    - 시간복잡도 O(N)으로 줄어든다.


#### code
``` java
import java.util.*;
import java.io.*;

public class Main {
    static Map<Integer,int[]> memo;
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //StringTokenizer st = new StringTokenizer(br.readLine());
        memo = new HashMap<>();
        memo.put(0,new int[]{1,0});
        memo.put(1,new int[]{0,1});
        
        int T = Integer.parseInt(br.readLine());
        while(T-- >0){
            int N = Integer.parseInt(br.readLine());
            int[] result =fibonacci(N);
            System.out.println(result[0]+" "+result[1]);
        }
        
    }
    static int[] fibonacci(int n){
        if(memo.containsKey(n)){
            return memo.get(n);
        }
        

        int[] result = new int[2];
        int[] prev1 = fibonacci(n-1);
        int[] prev2 = fibonacci(n-2);
        
        result[0] = prev1[0] + prev2[0];
        result[1] = prev1[1] + prev2[1]; 
        memo.put(n,result);
        
        return result;
    }
}
```
