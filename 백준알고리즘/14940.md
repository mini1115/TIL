[문제](https://www.acmicpc.net/problem/14940)
#### 풀이
    BFS 최단거리 탐색으로 모든거리를 탐색하면서, 이전에 방문한것에 대한 최단경로를 갱신해준다.
##### 시간복잡도
    O(N+M)
##### CODE
```JAVA
import java.util.*;
import java.io.*;
class Point{
    private int x;
    private int y;
    public Point(int x,int y){
        this.x =x;
        this.y= y;
    }
    public int getX(){
        return this.x;
    }
    public int getY(){
        return this.y;
    }
}
public class Main {
    static int x_target,y_target;
    static int N,M;
    static int[][] result;
    static int[][] map;
    static int[] dx = new int[]{-1,1,0,0};
    static int[] dy = new int[]{0,0,-1,1};
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        // 지도 세로 크기
        N = Integer.parseInt(st.nextToken());
        // 지도 가로 크기        
        M = Integer.parseInt(st.nextToken());
        
        // 지도생성
        map = new int[N][M];
        // 결과 배열
        result = new int[N][M];
        for(int i=0;i<N;i++){
            st = new StringTokenizer(br.readLine());
            for(int j=0;j<M;j++){
                int data = Integer.parseInt(st.nextToken());
                map[i][j] = data;
                if(data==2){
                    // 목표지점 확인
                    x_target=i;
                    y_target=j;
                }
                // 방문할수없는 곳이라면 0, 아니라면 -1 초기화
                result[i][j] = (data==0)    ?   0:-1;
            }
        }
        result[x_target][y_target] = 0;
        search();        // 탐색
        
        // 결과 출력        
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                System.out.print(result[i][j]+" ");
            }
            System.out.println();
        }
        
    }
    static void search(){
        Queue<Point> queue = new LinkedList<>();
        queue.add(new Point(x_target,y_target));

        while(!queue.isEmpty()){
            // 현재좌표 받아오기
            Point nowPoint = queue.poll();
            int px = nowPoint.getX();
            int py = nowPoint.getY();
            // 상하좌우 이동
            for(int i=0;i<4;i++){
                int nx = px+dx[i];
                int ny = py+dy[i];
                // 제한범위
                if(nx<0||ny<0||nx>=N||ny>=M){
                    continue;
                }
                // 갈수없은곳이거나 방문여부 확인
                if(map[nx][ny]==0 || result[nx][ny]!=-1){
                    continue;
                }
                // 거리정보 갱신신
                result[nx][ny] = result[px][py]+1;
                queue.add(new Point(nx,ny));
            }
        }

    } //search
}
```
