[문제](https://www.acmicpc.net/problem/2805)

#### 그리디 알고리즘 X 이진 탐색
    최선의 나무길이를 가지고 싶기때문에 mid 값을 (시작점+끝점)/2 으로 결과값을 비교하여 +1씩 -1씩 진행하니 시간 초과가 발생했다.
    따라서 그리디가 아닌 이진 탐색으로 문제를 해결했다.
#### 시간복잡도
    O(NlogH) : 나무의 개수 N , 나무의 높이 H 
    절반으로 높이를 줄여 나간다 O(logH)
    나무의 개수를 확인한다 O(N)
    
#### CODE
```JAVA
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String args[]) throws IOException {
        long answer =0;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        //첫째 줄에 나무의 수 N과 ,나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
       
        // 나무의 정보를 저장할 배열 생성
        int[] tree = new int[N];
        
        String[] data = br.readLine().split(" ");
        for(int i =0;i<N;i++){
            tree[i] = Integer.parseInt(data[i]);
        }
        Arrays.sort(tree);
        
        long low = 0;
        long high = tree[N-1];

        while(low<=high){
            long mid  = (low+high) / 2;
            long total = 0;
            for(int len : tree){
                //나무의 길이가 높이보다 클경우
                if(len>mid){
                    //남은 길이를 더해준다
                    total += len - mid;
                }
            }
            // 결과 검증
            // 남은 나무의 길이가 같거나 더 자를수 있을을 경우
            if(total>=M){
                answer = mid;
                low = mid+1;
            }else{
                // 나무가 부족한 경우
                high = mid-1;
            }
            
        }
        System.out.println(answer);
    }
}
```
