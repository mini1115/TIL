[문제](https://www.acmicpc.net/problem/1927)

### 풀이법
    단순 배열로 접근하니 N의 제한이  N(1 ≤ N ≤ 100,000)로 주어진다. 
    따라서 최소 힙 알고리즘으로 해당문제를 해결해야한다.
    java에서는 PriorityQueue를 통해 최소 힙을 구현한다
#### PriorityQueue
    우선순위 큐를 구현한 자료구조로, 내부적으로 최소 힙(Min Heap)을 사용하여 요소를 관리 
    - 동작원리
      완전 이진 트리의 형태로 구성되며, 최소 힙을 사용한다. 즉, 부모 노드의 값이 자식 노드의 값보다 작거나 같은 특성을 가진다. 따라서 가장 작은 값은 항상 루트 노드에 위치한다.

##### 메소드
    - 삽입(Insert)
      새 요소가 추가되면 배열의 마지막에 위치하고, 힙 속성을 유지하기 위해 부모 노드와 비교하며 위로 이동한다. 이 과정은 O(log n) 시간이 소요
    - 삭제(Remove)
      poll() 메서드를 사용하여 최솟값(루트 노드)을 삭제. 루트를 삭제한 후, 마지막 요소를 루트로 이동시키고 '힙다운(Heap Down)'을 통해 힙 속성을 복원. 이 과정도 O(log n) 시간이 소요
    - 최솟값 조회(Peek)
      peek() 메서드를 사용하여 최솟값을 조회. 이때 힙의 구조는 변경되지 않는다. 이 동작은 O(1) 시간 복잡도를 가진다.


``` java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        
        int N = Integer.parseInt(br.readLine());
        while(N-- >0){
            int data = Integer.parseInt(br.readLine());
            if(data==0){
                //큐가 비었다면
                if(queue.isEmpty()){
                    // 0을 출력
                    System.out.println(0);
                }else{
                    // 최솟값 출력
                    System.out.println(queue.poll());
                }
                
            }else{
                //요소 추가
                queue.add(data);
            }
        }
    }
}
```
